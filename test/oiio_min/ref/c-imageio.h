#pragma once

#include "c-filesystem.h"
#include "c-typedesc.h"
#include "cppmm_containers.h"


#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
#define CPPMM_ALIGN(x) __declspec(align(x))
#else
#define CPPMM_ALIGN(x) __attribute__((aligned(x)))
#endif

typedef struct {
    int xbegin;
    int xend;
    int ybegin;
    int yend;
    int zbegin;
    int zend;
    int chbegin;
    int chend;
} OpenImageIO_v2_2_ROI;

typedef struct OpenImageIO_v2_2_ImageInput OpenImageIO_v2_2_ImageInput;

typedef struct OpenImageIO_v2_2_ImageSpec OpenImageIO_v2_2_ImageSpec;

enum OpenImageIO_v2_2_ImageSpec_SerialVerbose {
    OIIO_ImageSpec_SerialVerbose_SerialBrief = 0,
    OIIO_ImageSpec_SerialVerbose_SerialDetailed = 1,
    OIIO_ImageSpec_SerialVerbose_SerialDetailedHuman = 2,
};

enum OpenImageIO_v2_2_ImageSpec_SerialFormat {
    OIIO_ImageSpec_SerialFormat_SerialText = 0,
    OIIO_ImageSpec_SerialFormat_SerialXML = 1,
};


/// Get the named global attribute of OpenImageIO, store it in `*val`.
/// Return `true` if found and it was compatible with the type specified,
/// otherwise return `false` and do not modify the contents of `*val`.  It
/// is up to the caller to ensure that `val` points to the right kind and
/// size of storage for the given type.
///
/// In addition to being able to retrieve all the attributes that are
/// documented as settable by the `OIIO::attribute()` call, `getattribute()`
/// can also retrieve the following read-only attributes:
///
/// - `string format_list`
/// - `string input_format_list`
/// - `string output_format_list`
///
///   A comma-separated list of all the names of, respectively, all
///   supported image formats, all formats accepted as inputs, and all
///   formats accepted as outputs.
///
/// - `string extension_list`
///
///   For each format, the format name, followed by a colon, followed by a
///   comma-separated list of all extensions that are presumed to be used
///   for that format.  Semicolons separate the lists for formats.  For
///   example,
///
///        "tiff:tif;jpeg:jpg,jpeg;openexr:exr"
///
/// - `string library_list`
///
///   For each format that uses a dependent library, the format name,
///   followed by a colon, followed by the name and version of the
///   dependency. Semicolons separate the lists for formats.  For example,
///
///        "tiff:LIBTIFF 4.0.4;gif:gif_lib 4.2.3;openexr:OpenEXR 2.2.0"
///
/// - string "timing_report"
///         A string containing the report of all the log_times.
///
/// - `string hw:simd`
/// - `string oiio:simd` (read-only)
///
///   A comma-separated list of hardware CPU features for SIMD (and some
///   other things). The `"oiio:simd"` attribute is similarly a list of
///   which features this build of OIIO was compiled to support.
///
///   This was added in OpenImageIO 1.8.
///
/// - `float resident_memory_used_MB`
///
///   This read-only attribute can be used for debugging purposes to report
///   the approximate process memory used (resident) by the application, in
///   MB.
///
/// - `string timing_report`
///
///    Retrieving this attribute returns the timing report generated by the
///    `log_timing` attribute (if it was enabled). The report is sorted
///    alphabetically and for each named instrumentation region, prints the
///    number of times it executed, the total runtime, and the average per
///    call, like this:
///
///        IBA::computePixelStats        2   2.69ms  (avg   1.34ms)
///        IBA::make_texture             1  74.05ms  (avg  74.05ms)
///        IBA::mul                      8   2.42ms  (avg   0.30ms)
///        IBA::over                    10  23.82ms  (avg   2.38ms)
///        IBA::resize                  20   0.24s   (avg  12.18ms)
///        IBA::zero                     8   0.66ms  (avg   0.08ms)
///
bool OpenImageIO_v2_2_getattribute(const char* name, OpenImageIO_v2_2_TypeDesc type, void* val);

/// Union of two regions, the smallest region containing both.
OpenImageIO_v2_2_ROI OpenImageIO_v2_2_roi_union(const OpenImageIO_v2_2_ROI* A, const OpenImageIO_v2_2_ROI* B);

/// Intersection of two regions.
OpenImageIO_v2_2_ROI OpenImageIO_v2_2_roi_intersection(const OpenImageIO_v2_2_ROI* A, const OpenImageIO_v2_2_ROI* B);

/// All() is an alias for the default constructor, which indicates that
/// it means "all" of the image, or no region restriction.  For example,
///     float myfunc (ImageBuf &buf, ROI roi = ROI::All());
/// Note that this is equivalent to:
///     float myfunc (ImageBuf &buf, ROI roi = {});
OpenImageIO_v2_2_ROI OpenImageIO_v2_2_ROI_All();

/// Total number of pixels in the region.
unsigned long OpenImageIO_v2_2_ROI_npixels(const OpenImageIO_v2_2_ROI* self);

/// Default constructor is an undefined region. Note that this is also
/// interpreted as All().
void OpenImageIO_v2_2_ROI_default(OpenImageIO_v2_2_ROI* self);

/// Number of channels in the region.  Beware -- this defaults to a
/// huge number, and to be meaningful you must consider
/// std::min (imagebuf.nchannels(), roi.nchannels()).
int OpenImageIO_v2_2_ROI_nchannels(const OpenImageIO_v2_2_ROI* self);

///@{
/// @name Spatial size functions.
/// The width, height, and depth of the region.
int OpenImageIO_v2_2_ROI_width(const OpenImageIO_v2_2_ROI* self);


int OpenImageIO_v2_2_ROI_height(const OpenImageIO_v2_2_ROI* self);

/// Is a region defined?
bool OpenImageIO_v2_2_ROI_defined(const OpenImageIO_v2_2_ROI* self);


int OpenImageIO_v2_2_ROI_depth(const OpenImageIO_v2_2_ROI* self);

/// If any of the API routines returned false indicating an error, this
/// method will return the error string (and clear any error flags).  If
/// no error has occurred since the last time `geterror()` was called,
/// it will return an empty string.
int OpenImageIO_v2_2_ImageInput_geterror(const OpenImageIO_v2_2_ImageInput* self, char* _result_buffer_ptr, int _result_buffer_len);

/// Create an ImageInput subclass instance that is able to read the
/// given file and open it, returning a `unique_ptr` to the ImageInput
/// if successful.  The `unique_ptr` is set up with an appropriate
/// deleter so the ImageInput will be properly closed and deleted when
/// the `unique_ptr` goes out of scope or is reset. If the open fails,
/// return an empty `unique_ptr` and set an error that can be retrieved
/// by `OIIO::geterror()`.
///
/// The `config`, if not nullptr, points to an ImageSpec giving hints,
/// requests, or special instructions.  ImageInput implementations are
/// free to not respond to any such requests, so the default
/// implementation is just to ignore `config`.
///
/// `open()` will first try to make an ImageInput corresponding to
/// the format implied by the file extension (for example, `"foo.tif"`
/// will try the TIFF plugin), but if one is not found or if the
/// inferred one does not open the file, every known ImageInput type
/// will be tried until one is found that will open the file.
///
/// @param filename
///         The name of the file to open.
///
/// @param config
///         Optional pointer to an ImageSpec whose metadata contains
///         "configuration hints."
///
/// @param ioproxy
///         Optional pointer to an IOProxy to use (not supported by all
///         formats, see `supports("ioproxy")`). The caller retains
///         ownership of the proxy.
///
/// @returns
///         A `unique_ptr` that will close and free the ImageInput when
///         it exits scope or is reset. The pointer will be empty if the
///         required writer was not able to be created.
OpenImageIO_v2_2_ImageInput* OpenImageIO_v2_2_ImageInput_open(const char* filename, const OpenImageIO_v2_2_ImageSpec* config, OpenImageIO_v2_2_Filesystem_IOProxy* ioproxy);

/// Return the name of the format implemented by this class.
const char* OpenImageIO_v2_2_ImageInput_format_name(const OpenImageIO_v2_2_ImageInput* self);

/// Fill in an array of channel formats describing all channels in
/// the image.  (Note that this differs slightly from the member
/// data channelformats, which is empty if there are not separate
/// per-channel formats.)
void OpenImageIO_v2_2_ImageSpec_get_channelformats(const OpenImageIO_v2_2_ImageSpec* self, OpenImageIO_v2_2_TypeDesc_vector* formats);


OpenImageIO_v2_2_ImageSpec* OpenImageIO_v2_2_ImageSpec_copy(const OpenImageIO_v2_2_ImageSpec* other);

/// Returns, as a string, a serialized version of the `ImageSpec`. The
/// `format` may be either `ImageSpec::SerialText` or
/// `ImageSpec::SerialXML`. The `verbose` argument may be one of:
/// `ImageSpec::SerialBrief` (just resolution and other vital
/// statistics, one line for `SerialText`, `ImageSpec::SerialDetailed`
/// (contains all metadata in original form), or
/// `ImageSpec::SerialDetailedHuman` (contains all metadata, in many
/// cases with human-readable explanation).
int OpenImageIO_v2_2_ImageSpec_serialize(const OpenImageIO_v2_2_ImageSpec* self, int format, int verbose, char* _result_buffer_ptr, int _result_buffer_len);

/// Adjust the stride values, if set to AutoStride, to be the right
/// sizes for contiguous data with the given format, channels,
/// width, height.
void OpenImageIO_v2_2_ImageSpec_auto_stride(long* xstride, long* ystride, long* zstride, long channelsize, int nchannels, int width, int height);

/// Constructs an `ImageSpec` with the given x and y resolution, number
/// of channels, and pixel data format.
///
/// All other fields are set to the obvious defaults -- the image is an
/// ordinary 2D image (not a volume), the image is not offset or a crop
/// of a bigger image, the image is scanline-oriented (not tiled),
/// channel names are "R", "G", "B"' and "A" (up to and including 4
/// channels, beyond that they are named "channel *n*"), the fourth
/// channel (if it exists) is assumed to be alpha.
OpenImageIO_v2_2_ImageSpec* OpenImageIO_v2_2_ImageSpec_new_with_dimensions(int xres, int yres, int nchans, OpenImageIO_v2_2_TypeDesc fmt);

/// Returns the number of bytes comprising each channel of each pixel
/// (i.e., the size of a single value of the type described by the
/// `format` field).
unsigned long OpenImageIO_v2_2_ImageSpec_channel_bytes(const OpenImageIO_v2_2_ImageSpec* self);

/// Returns the number of bytes comprising each scanline, i.e.,
/// `pixel_bytes(native) * width` This will return
/// `std::numeric_limits<imagesize_t>::max()` in the event of an
/// overflow where it's not representable in an `imagesize_t`.
unsigned long OpenImageIO_v2_2_ImageSpec_scanline_bytes(const OpenImageIO_v2_2_ImageSpec* self, bool native);

/// Constructor: given just the data format, set all other fields to
/// something reasonable.
OpenImageIO_v2_2_ImageSpec* OpenImageIO_v2_2_ImageSpec_new(OpenImageIO_v2_2_TypeDesc format);

/// Sets the `channelnames` to reasonable defaults for the number of
/// channels.  Specifically, channel names are set to "R", "G", "B,"
/// and "A" (up to and including 4 channels, beyond that they are named
/// "channel*n*".
void OpenImageIO_v2_2_ImageSpec_default_channel_names(OpenImageIO_v2_2_ImageSpec* self);


OpenImageIO_v2_2_ImageSpec* OpenImageIO_v2_2_ImageSpec_assign(OpenImageIO_v2_2_ImageSpec* self, const OpenImageIO_v2_2_ImageSpec* other);

/// Set the data format, and clear any per-channel format information
/// in `channelformats`.
void OpenImageIO_v2_2_ImageSpec_set_format(OpenImageIO_v2_2_ImageSpec* self, OpenImageIO_v2_2_TypeDesc fmt);

/// Add a metadata attribute to `extra_attribs`, with the given name and
/// data type. The `value` pointer specifies the address of the data to
/// be copied.
void OpenImageIO_v2_2_ImageSpec_attribute(OpenImageIO_v2_2_ImageSpec* self, const char* name, OpenImageIO_v2_2_TypeDesc type, const void* value);

/// Return the number of bytes needed for the single specified
/// channel.  If native is false (default), compute the size of one
/// channel of `this->format`, but if native is true, compute the size
/// of the channel in terms of the "native" data format of that
/// channel as stored in the file.
unsigned long OpenImageIO_v2_2_ImageSpec_channel_bytes_for(const OpenImageIO_v2_2_ImageSpec* self, int chan, bool native);


#undef CPPMM_ALIGN

#define OIIO_ROI OpenImageIO_v2_2_ROI
#define OIIO_ImageInput OpenImageIO_v2_2_ImageInput
#define OIIO_ImageSpec OpenImageIO_v2_2_ImageSpec
#define OIIO_ImageSpec_SerialVerbose OpenImageIO_v2_2_ImageSpec_SerialVerbose
#define OIIO_ImageSpec_SerialFormat OpenImageIO_v2_2_ImageSpec_SerialFormat
#define OIIO_getattribute OpenImageIO_v2_2_getattribute
#define OIIO_roi_union OpenImageIO_v2_2_roi_union
#define OIIO_roi_intersection OpenImageIO_v2_2_roi_intersection
#define OIIO_ROI_All OpenImageIO_v2_2_ROI_All
#define OIIO_ROI_npixels OpenImageIO_v2_2_ROI_npixels
#define OIIO_ROI_default OpenImageIO_v2_2_ROI_default
#define OIIO_ROI_nchannels OpenImageIO_v2_2_ROI_nchannels
#define OIIO_ROI_width OpenImageIO_v2_2_ROI_width
#define OIIO_ROI_height OpenImageIO_v2_2_ROI_height
#define OIIO_ROI_defined OpenImageIO_v2_2_ROI_defined
#define OIIO_ROI_depth OpenImageIO_v2_2_ROI_depth
#define OIIO_ImageInput_geterror OpenImageIO_v2_2_ImageInput_geterror
#define OIIO_ImageInput_open OpenImageIO_v2_2_ImageInput_open
#define OIIO_ImageInput_format_name OpenImageIO_v2_2_ImageInput_format_name
#define OIIO_ImageSpec_get_channelformats OpenImageIO_v2_2_ImageSpec_get_channelformats
#define OIIO_ImageSpec_copy OpenImageIO_v2_2_ImageSpec_copy
#define OIIO_ImageSpec_serialize OpenImageIO_v2_2_ImageSpec_serialize
#define OIIO_ImageSpec_auto_stride OpenImageIO_v2_2_ImageSpec_auto_stride
#define OIIO_ImageSpec_new_with_dimensions OpenImageIO_v2_2_ImageSpec_new_with_dimensions
#define OIIO_ImageSpec_channel_bytes OpenImageIO_v2_2_ImageSpec_channel_bytes
#define OIIO_ImageSpec_scanline_bytes OpenImageIO_v2_2_ImageSpec_scanline_bytes
#define OIIO_ImageSpec_new OpenImageIO_v2_2_ImageSpec_new
#define OIIO_ImageSpec_default_channel_names OpenImageIO_v2_2_ImageSpec_default_channel_names
#define OIIO_ImageSpec_assign OpenImageIO_v2_2_ImageSpec_assign
#define OIIO_ImageSpec_set_format OpenImageIO_v2_2_ImageSpec_set_format
#define OIIO_ImageSpec_attribute OpenImageIO_v2_2_ImageSpec_attribute
#define OIIO_ImageSpec_channel_bytes_for OpenImageIO_v2_2_ImageSpec_channel_bytes_for

#ifdef __cplusplus
}
#endif
    